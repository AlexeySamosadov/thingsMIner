"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighloadWalletV2 = void 0;
const core_1 = require("@ton/core");
const crypto_1 = require("@ton/crypto");
const BatchSender_1 = require("./BatchSender");
class HighloadWalletV2 {
    constructor(publicKey, workchain = 0, walletId = workchain + 0x29a9a317) {
        this.publicKey = publicKey;
        this.workchain = workchain;
        this.walletId = walletId;
        this.init = {
            code: core_1.Cell.fromBase64(HighloadWalletV2.CODE),
            data: (0, core_1.beginCell)()
                .storeUint(this.walletId, 32)
                .storeUint(0, 64) // last_cleaned
                .storeBuffer(this.publicKey, 32)
                .storeDict(null) // old_queries
                .endCell(),
        };
        this.address = (0, core_1.contractAddress)(workchain, this.init);
    }
    async sendDeploy(provider, via, value) {
        await provider.internal(via, {
            value,
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
            body: (0, core_1.beginCell)().endCell(),
        });
    }
    async getBalance(provider) {
        let state = await provider.getState();
        return state.balance;
    }
    async getProcessed(provider, queryId) {
        const { stack } = await provider.get('processed?', [
            { type: 'int', value: queryId },
        ]);
        return stack.readBoolean();
    }
    generateQueryId(timeout, randomId) {
        const now = Math.floor(Date.now() / 1000);
        const random = randomId || Math.floor(Math.random() * 2 ** 30);
        return (BigInt(now + (timeout ?? 60)) << 32n) | BigInt(random);
    }
    /**
     * Send signed transfer
     */
    async send(provider, message) {
        await provider.external(message);
    }
    /**
     * Sign and send transfer
     */
    async sendTransfer(provider, args) {
        const transfer = this.createTransfer(args);
        await this.send(provider, transfer);
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
        if (!args.messages.length || args.messages.length > 254) {
            throw new Error('HighloadWalletV2: can make only 1 to 254 transfers per operation.');
        }
        const messages = core_1.Dictionary.empty(core_1.Dictionary.Keys.Int(16), {
            serialize(src, builder) {
                builder
                    .storeUint(src.mode, 8)
                    .storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(src.message)));
            },
            parse(src) {
                return {
                    mode: src.loadUint(8),
                    message: (0, core_1.loadMessageRelaxed)(src.loadRef().beginParse()),
                };
            },
        });
        for (let i = 0; i < args.messages.length; i++) {
            const [message, mode] = args.messages[i];
            messages.set(i, {
                message,
                mode,
            });
        }
        const signingMessage = (0, core_1.beginCell)()
            .storeUint(this.walletId, 32)
            .storeUint(args.queryId, 64)
            .storeDict(messages);
        const signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
        return (0, core_1.beginCell)()
            .storeBuffer(signature)
            .storeBuilder(signingMessage)
            .endCell();
    }
    /**
     * Create a default sender (sends 1 message per time)
     */
    sender(provider, secretKey) {
        return {
            send: (args) => this.sendTransfer(provider, {
                queryId: this.generateQueryId(),
                messages: [
                    [
                        (0, core_1.internal)({
                            to: args.to,
                            value: args.value,
                            init: args.init,
                            body: args.body,
                            bounce: args.bounce,
                        }),
                        args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
                    ],
                ],
                secretKey,
            }),
        };
    }
    /**
     * Create a batch sender (sends as many messages as needed).
     * Non-compatible with `Blockchain` from `@ton/sandbox`.
     */
    batchSender(provider, secretKey, batchSize) {
        return new BatchSender_1.BatchSender(provider, this, secretKey, batchSize);
    }
}
exports.HighloadWalletV2 = HighloadWalletV2;
HighloadWalletV2.CODE = 'te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQHq8oMI1xgg0x/TP/gjqh9TILnyY+1E0NMf0z/T//QE0VNggED0Dm+hMfJgUXO68qIH+QFUEIf5EPKjAvQE0fgAf44WIYAQ9HhvpSCYAtMH1DAB+wCRMuIBs+ZbgyWhyEA0gED0Q4rmMQHIyx8Tyz/L//QAye1UCAAE0DACASAGBwAXvZznaiaGmvmOuF/8AEG+X5dqJoaY+Y6Z/p/5j6AmipEEAgegc30JjJLb/JXdHxQANCCAQPSWb6VsEiCUMFMDud4gkzM2AZJsIeKz';
//# sourceMappingURL=HighloadWalletV2.js.map